using System;
using System.Linq;
using System.IO;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace MalwareDetector.BusinessLogic
{
    /// <summary>
    /// Класс, содержащий логику сканирования файлов
    /// </summary>
    internal class Scanner
    {
        /// <summary>
        /// Путь к директории сканирования.
        /// </summary>
        private string _directoryPath { get; }
        /// <summary>
        /// Коллекция правил сканирования.
        /// </summary>
        private IEnumerable<ScanRule> _scanRules { get; }
        /// <summary>
        /// Конструктор.
        /// </summary>
        /// <param name="directoryPath">Сканируемая директория.</param>
        /// <param name="scanRules">Коллекция правил сканирования.</param>
        internal Scanner(string directoryPath, IEnumerable<ScanRule> scanRules)
        {
            _directoryPath = directoryPath;
            _scanRules = scanRules;
        }
        /// <summary>
        /// Запуск процесса сканирования.
        /// </summary>
        /// <returns>Объект отчета сканирования.</returns>
        internal ScanReport Scan()
        {
            ScanReport report = new ScanReport();
            report.StartScanning();

            IEnumerable<string> files = Directory.GetFiles(_directoryPath, "*", SearchOption.AllDirectories);

            Parallel.ForEach(files, file =>
            {
                bool isClear = true;
                try
                {
                    using (StreamReader reader = new StreamReader(file))
                    {
                        string text = reader.ReadToEnd();
                        string[] textLines = text.Split("\n");
                        foreach (var rule in _scanRules)
                        {
                            if (rule.CheckFileExtension(file))
                            {
                                if (ScanText(textLines, rule))
                                {
                                    report.AddFileReport(new FileReport(Path.GetFileName(file), FileReportType.Malware, "", rule));
                                    isClear = false;
                                    break;
                                }
                            }
                        }
                        if (isClear)
                            report.AddFileReport(new FileReport(Path.GetFileName(file), FileReportType.Clear, "", null));
                    }
                }
                catch (Exception e)
                {
                    report.AddFileReport(new FileReport(Path.GetFileName(file), FileReportType.Error, e.Message, null));
                }
            });
            report.EndScanning();
            return report;
        }
        /// <summary>
        /// Поиск в строках файла, соответствующей вредоносной строки правила.
        /// </summary>
        /// <param name="textLines">Строки файла.</param>
        /// <param name="rule">Правило сканирования.</param>
        /// <returns>True, если вредоносная строка найдена</returns>
        private bool ScanText(string[] textLines, ScanRule rule)
        {
            foreach (var str in textLines)
            {
                if (str.Trim() == rule.MalwareString)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
