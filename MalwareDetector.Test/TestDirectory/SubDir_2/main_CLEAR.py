import json
import os
import pickle
import shutil
import smtplib
import threading
import uuid
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
import aiohttp_cors
from aiohttp import web
from classes.lastrequest import LastRequest
from os import walk

dirname = os.path.dirname(__file__)
TEMPLATES_HTML_BUILD_PATH = os.path.join(dirname, "templates", "HtmlBuild")
WORDS_PATH = os.path.join(dirname, "words")
HTML_DIST_PATH = os.path.join(dirname, "public", "dist")

routes = web.RouteTableDef()
last_requests = []
all_words = []


def send_email(to, lid, success):
    if success:
        message = f'You translate is done! <a href="https://goge.tech/public/{lid}/index.html">Got it!</a>'
    else:
        message = f'You translate is fail! We are already dealing with it. Please try again later.'

    me = "service.account@goge.tech"
    msg = MIMEMultipart('alternative')
    msg['Subject'] = "Your translate from GoGe"
    msg['From'] = me
    msg['To'] = to
    part = MIMEText(message, 'html')
    msg.attach(part)

    s = smtplib.SMTP('smtp.zoho.com', 587)
    s.starttls()
    s.login('service.account@goge.tech', 'ADev64Dev!')
    s.sendmail(me, to, msg.as_string())
    s.quit()


def html_response(document):
    s = open(document, "r")
    return web.Response(text=s.read(), content_type='text/html')


def copytree(src, dst, symlinks=False, ignore=None):
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore)
        else:
            shutil.copy2(s, d)


@routes.get('/')
async def hello(request):
    return html_response(os.path.join(dirname, "public", "index.html"))


@routes.get('/public/{lid}/index.html')
async def hello(request):
    return html_response(os.path.join(dirname, "public", "main", "index.html"))


@routes.get('/roadmap')
async def roadmap(request):
    return html_response(os.path.join(dirname, "public", "roadmap.html"))


def create_new_from_build(lid, email):
    try:
        [x.set_complete() for x in last_requests if x.lid == lid]
    except:
        [x.set_fail() for x in last_requests if x.lid == lid]
        pickle.dump(last_requests, open(os.path.join(dirname, "data.dat"),
                                        'wb'))


@routes.get('/ask/{lid}')
async def handler(request):
    if not request.match_info['lid']:
        return web.Response(status=400)
    req = next(
        (x for x in last_requests if x.lid == request.match_info['lid']), None)
    if req:
        return web.json_response({
            'id': req.lid,
            'complete': req.complete,
            'fail': req.fail
        })
    return web.json_response({
        'id': request.match_info['lid'],
        'complete': False
    })


@routes.get('/last')
async def handler(request):
    # todo check if not fail
    return web.json_response(
        json.dumps([
            x.__dict__ for x in last_requests if x.complete and not x.fail
        ][:5]))


@routes.get('/words')
async def handler(request):
    return web.json_response(json.dumps(all_words))


async def get_word(request):
    word = request.match_info['word']
    w_file = Path(os.path.join(WORDS_PATH, 'en', f'{word.lower()}.json'))
    if not w_file.is_file():
        spell = list(word)
        flist = []
        spells_dics = []
        spell_pos = 0
        for s in spell:
            w_file = Path(os.path.join(WORDS_PATH, 'en', f'{s.lower()}.json'))
            if w_file.is_file():
                with open(w_file) as file:
                    json_o = json.loads(file.read())
                    file.close()
                    spells_dics.append({
                        "letter":
                        s.lower(),
                        "start":
                        spell_pos,
                        "end":
                        spell_pos + len(json_o['frames']) - 1
                    })
                    spell_pos = spell_pos + len(json_o['frames'])
                    flist.extend(json_o['frames'])
        return web.json_response({
            'frames': list(flist),
            'spell': len(spells_dics) > 0,
            'spells': spells_dics,
            "word": word
        })
    with open(w_file) as file:
        json_o = json.load(file)
        file.close()
        json_o['spells'] = []
        json_o['spell'] = False
        json_o['word"'] = word
        return web.json_response(json_o)


async def get_phrase(request):
    pid = request.match_info['pid']
    if pid == 'test':
        return web.Response(
            text=
            'Little',
            status=200)
    if pid == 'demo1':
        return web.Response(text='Hi, I am a sign language translater',
                            status=200)
    if pid == 'demo2':
        return web.Response(text='See how I translated this phrase',
                            status=200)
    if pid == 'demo3':
        return web.Response(text='What is your name?', status=200)
    if pid == 'demo4':
        return web.Response(text='We are waiting for you today at 5 pm',
                            status=200)
    if pid == 'demo5':
        return web.Response(
            text=
            'Radius - a straight line connecting the center to any point on the circle',
            status=200)
    if pid == 'demo6':
        return web.Response(
            text=
            'It took me a long time to learn where he came from. The little prince, who asked me so many questions, never seemed to hear the ones I asked him. It was from words dropped by chance that, little by little, everything was revealed to me. The first time he saw my airplane, for instance(I shall not draw my airplane; that would be much too complicated for me)',
            status=200)
    else:
        for r in last_requests:
            if r.lid == pid:
                return web.Response(text=r.phrase, status=200)
        return web.Response(text='This request was not found', status=200)


async def get_phrase_default(request):
    return web.Response(
        text='hello hello hello hello please no yes good family', status=200)


@routes.post('/new')
async def variable_handler(request):
    json_req = await request.json()
    text_to_show = json_req['phrase']
    email = json_req['email']
    lid = uuid.uuid4().hex
    last_requests.append(LastRequest(text_to_show, False, lid, email))
    pickle.dump(last_requests, open(os.path.join(dirname, "data.dat"), 'wb'))
    ctr = threading.Thread(target=create_new_from_build,
                           name='Create',
                           args=[lid, email])
    ctr.start()
    return web.json_response({'id': lid, 'phrase': text_to_show})


#outes.static('/public/{:.*}/dict', './public/dist')
routes.static('/dist', HTML_DIST_PATH)
app = web.Application()
app.add_routes(routes)

cors = aiohttp_cors.setup(app,
                          defaults={
                              "*":
                              aiohttp_cors.ResourceOptions(
                                  allow_credentials=True,
                                  expose_headers="*",
                                  allow_headers="*",
                              )
                          })

resource = cors.add(app.router.add_resource("/words/{word}"))
cors.add(resource.add_route("GET", get_word), {
    "*":
    aiohttp_cors.ResourceOptions(expose_headers="*", allow_headers="*"),
})

resource = cors.add(app.router.add_resource("/phrase/{pid}"))
cors.add(resource.add_route("GET", get_phrase), {
    "*":
    aiohttp_cors.ResourceOptions(expose_headers="*", allow_headers="*"),
})

resource = cors.add(app.router.add_resource("/phrase/"))
cors.add(resource.add_route("GET", get_phrase_default), {
    "*":
    aiohttp_cors.ResourceOptions(expose_headers="*", allow_headers="*"),
})

my_file = Path(os.path.join(dirname, "data.dat"))
if not my_file.is_file():
    with open(os.path.join(dirname, "data.dat"), 'wb'):
        pass

try:
    last_requests = pickle.load(open(os.path.join(dirname, "data.dat"), 'rb'))
except:
    pass

print('run render server')

filenames = next(walk(os.path.join(WORDS_PATH, 'en')), (None, None, []))[2]
for w in filenames:
    all_words.append(w.replace(".json", ""))

web.run_app(app, port=8080)
